"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
var Clients_1 = require("./Clients");
var ApiRequest_1 = require("./ApiRequest");
/**
 * Entry class for accessing the Content Delivery and Content Management APIs.
 * @public
 *
 * @example
 *
 * To get started you need create a new instance of the `Client` passing {@link ClientOptions}.
 *
 * ```typescript
 * import { Client } from '@umbraco/headless-client'
 *
 * const client = new Client({
 *  projectAlias: '<your-project-alias>',
 *  apiKey: '<your-api-key>',
 *  language: '<iso-code>',
 * })
 * ```
 *
 * You might want to proxy your request through a server to hide the project alias and the api key,
 * this can be done by creating a new instance of the `Client` class passing in {@link ProxyOptions}.
 *
 * ```typescript
 * import { Client } from '@umbraco/headless-client'
 *
 * const client = new Client({
 *  apiProxyUrl: '<proxy-url>',
 *  cdnProxyUrl: '<proxy-url>',
 *  language: '<iso-code>',
 * })
 * ```
 *
 */
var Client = /** @class */ (function () {
    /**
     * Constructs a new instance of the `Client` class with the given options.
     * @param options - The options. See {@link ClientOptions} or {@link ProxyOptions}.
     */
    function Client(options) {
        var _this = this;
        this.options = options;
        /**
         * Get Delivery client for fetching content and media from CDN.
         * See {@link DeliveryClient}
         */
        this.delivery = new Clients_1.DeliveryClient(this);
        /**
         * Get Manager Client for managing content on Umbraco Heartcore.
         * See {@link ManagementClient}
         */
        this.management = new Clients_1.ManagementClient(this);
        /**
         * Get Authentication Client for authenticating members and Backoffice users.
         * See {@link AuthenticationClient}
         */
        this.authentication = new Clients_1.AuthenticationClient(this);
        /**
         * Makes request from and [Endpoint]
         * @internal
         */
        this.makeRequest = function (endpoint, data) { return __awaiter(_this, void 0, void 0, function () {
            var response, items, pageData, _embedded, _links, data_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new ApiRequest_1.ApiRequest(this.options, endpoint, data).promise()];
                    case 1:
                        response = _a.sent();
                        items = this.getEmbeddedData(response);
                        pageData = this.getPagedData(response);
                        if (pageData && items) {
                            return [2 /*return*/, __assign(__assign({}, pageData), { items: items })];
                        }
                        else if (!pageData && items) {
                            _embedded = response._embedded, _links = response._links, data_1 = __rest(response, ["_embedded", "_links"]);
                            if (Object.keys(data_1).length) {
                                return [2 /*return*/, __assign(__assign({}, _embedded), data_1)];
                            }
                            return [2 /*return*/, items];
                        }
                        return [2 /*return*/, response];
                }
            });
        }); };
        /**
         * Sets the API to be used.
         * @param apikey - API Key
         * @deprecated Use `apiKey` in the constructor options instead.
         */
        this.setAPIKey = function (apikey) {
            if ('apiKey' in _this.options) {
                _this.options.apiKey = apikey;
            }
            else {
                throw Error('Cannot set apiKey on ProxyOptions');
            }
        };
        /**
         * @deprecated Use `options.apiKey` instead.
         */
        this.getAPIKey = function () {
            if ('apiKey' in _this.options) {
                return _this.options.apiKey;
            }
            else {
                throw Error('Cannot set apiKey on ProxyOptions');
            }
        };
        this.getEmbeddedData = function (response) {
            if (Object.prototype.hasOwnProperty.call(response, '_embedded')) {
                var keys = Object.keys(response._embedded);
                var keyCount = keys.length;
                if (keyCount === 1) {
                    var key = keys[0];
                    return response._embedded[key];
                }
            }
            return null;
        };
        this.getPagedData = function (response) {
            var lookForProps = ['_totalItems', '_totalPages', '_page', '_pageSize'];
            var keys = Object.keys(response);
            for (var i = 0; i < lookForProps.length; i++) {
                var needle = lookForProps[i];
                if (!keys.includes(needle))
                    return null;
            }
            var object = {};
            lookForProps.forEach(function (key) {
                object[key.replace(/^_/, '')] = response[key];
            });
            return object;
        };
    }
    return Client;
}());
exports.Client = Client;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2xpZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL0NsaWVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEscUNBQWtGO0FBRWxGLDJDQUF5QztBQXFEekM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErQkc7QUFDSDtJQUNFOzs7T0FHRztJQUNILGdCQUE2QixPQUFxQztRQUFsRSxpQkFFQztRQUY0QixZQUFPLEdBQVAsT0FBTyxDQUE4QjtRQUlsRTs7O1dBR0c7UUFDYSxhQUFRLEdBQUcsSUFBSSx3QkFBYyxDQUFDLElBQUksQ0FBQyxDQUFBO1FBRW5EOzs7V0FHRztRQUNhLGVBQVUsR0FBRyxJQUFJLDBCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFBO1FBRXZEOzs7V0FHRztRQUNhLG1CQUFjLEdBQUcsSUFBSSw4QkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FBQTtRQUUvRDs7O1dBR0c7UUFDSSxnQkFBVyxHQUFHLFVBQXNCLFFBQXFCLEVBQUUsSUFBVTs7Ozs0QkFDekQscUJBQU0sSUFBSSx1QkFBVSxDQUFNLElBQUksQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFBOzt3QkFBNUUsUUFBUSxHQUFHLFNBQWlFO3dCQUM1RSxLQUFLLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQTt3QkFDdEMsUUFBUSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUE7d0JBRTVDLElBQUksUUFBUSxJQUFJLEtBQUssRUFBRTs0QkFDckIsNENBQ0ssUUFBUSxLQUNYLEtBQUssT0FBQSxLQUNOO3lCQUNGOzZCQUFNLElBQUksQ0FBQyxRQUFRLElBQUksS0FBSyxFQUFFOzRCQUNyQixTQUFTLEdBQXNCLFFBQVEsVUFBOUIsRUFBRSxNQUFNLEdBQWMsUUFBUSxPQUF0QixFQUFFLGdCQUFZLFFBQVEsRUFBekMsdUJBQThCLENBQUYsQ0FBYTs0QkFDL0MsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQUksQ0FBQyxDQUFDLE1BQU0sRUFBRTtnQ0FDNUIsNENBQVksU0FBUyxHQUFLLE1BQUksR0FBRTs2QkFDakM7NEJBQ0Qsc0JBQU8sS0FBSyxFQUFBO3lCQUNiO3dCQUNELHNCQUFPLFFBQVEsRUFBQTs7O2FBQ2hCLENBQUE7UUFFRDs7OztXQUlHO1FBQ0ksY0FBUyxHQUFHLFVBQUMsTUFBYztZQUNoQyxJQUFHLFFBQVEsSUFBSSxLQUFJLENBQUMsT0FBTyxFQUFFO2dCQUMzQixLQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUE7YUFDN0I7aUJBQU07Z0JBQ0wsTUFBTSxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQTthQUNqRDtRQUNILENBQUMsQ0FBQTtRQUVEOztXQUVHO1FBQ0ksY0FBUyxHQUFHO1lBQ2pCLElBQUcsUUFBUSxJQUFJLEtBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQzNCLE9BQU8sS0FBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUE7YUFDM0I7aUJBQU07Z0JBQ0wsTUFBTSxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQTthQUNqRDtRQUNILENBQUMsQ0FBQTtRQUVnQixvQkFBZSxHQUFHLFVBQUMsUUFBYTtZQUMvQyxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLEVBQUU7Z0JBQy9ELElBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFBO2dCQUM1QyxJQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFBO2dCQUM1QixJQUFJLFFBQVEsS0FBSyxDQUFDLEVBQUU7b0JBQ2xCLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQTtvQkFDbkIsT0FBTyxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFBO2lCQUMvQjthQUNGO1lBRUQsT0FBTyxJQUFJLENBQUE7UUFDYixDQUFDLENBQUE7UUFFZ0IsaUJBQVksR0FBRyxVQUFDLFFBQWE7WUFDNUMsSUFBTSxZQUFZLEdBQUcsQ0FBQyxhQUFhLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQTtZQUN6RSxJQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFBO1lBRWxDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUM1QyxJQUFNLE1BQU0sR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUE7Z0JBQzlCLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQztvQkFBRSxPQUFPLElBQUksQ0FBQTthQUN4QztZQUVELElBQU0sTUFBTSxHQUFRLEVBQUUsQ0FBQTtZQUN0QixZQUFZLENBQUMsT0FBTyxDQUFDLFVBQUEsR0FBRztnQkFDdEIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFBO1lBQy9DLENBQUMsQ0FBQyxDQUFBO1lBRUYsT0FBTyxNQUFNLENBQUE7UUFDZixDQUFDLENBQUE7SUFoR0QsQ0FBQztJQWlHSCxhQUFDO0FBQUQsQ0FBQyxBQXhHRCxJQXdHQztBQXhHWSx3QkFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hbmFnZW1lbnRDbGllbnQsIERlbGl2ZXJ5Q2xpZW50LCBBdXRoZW50aWNhdGlvbkNsaWVudCB9IGZyb20gJy4vQ2xpZW50cydcbmltcG9ydCB7IEVuZHBvaW50IH0gZnJvbSAnLi9FbmRwb2ludCdcbmltcG9ydCB7IEFwaVJlcXVlc3QgfSBmcm9tICcuL0FwaVJlcXVlc3QnXG5cbi8qKlxuICogQ2xpZW50IE9wdGlvbnNcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDbGllbnRPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBQcm9qZWN0IEFsaWFzIGlzIGEgSFRUUCBmcmllbmRseSB2ZXJzaW9uIG9mIHRoZSBQcm9qZWN0IE5hbWUgdW5kZXIgeW91ciBVbWJyYWNvIENsb3VkIGFjY291bnQuXG4gICAqL1xuICBwcm9qZWN0QWxpYXM6IHN0cmluZ1xuICAvKipcbiAgICogVGhlIGRlZmF1bHQgY3VsdHVyZSBzZW50IHdpdGggYWxsIHJlcXVlc3RzIHRvIHRoZSBDb250ZW50IERlbGl2ZXJ5IEFQSSwgdGhpcyBjYW4gYmUgb3ZlcndyaXR0ZW4gcGVyIGZ1bmN0aW9uXG4gICAqL1xuICBsYW5ndWFnZT86IHN0cmluZ1xuICAvKipcbiAgICogQW4gQVBJIEtleSBpcyByZXF1aWVyZCB3aGVuIGludGVyYWN0aW5nIHdpdGggdGhlIE1hbmFnZW1lbnQgQVBJIGFuZCB3aGVuIHByb3RlY3Rpb24gaXMgZW5hYmxlZCBmb3IgdGhlIERlbGl2ZXJ5IEFQSVxuICAgKi9cbiAgYXBpS2V5Pzogc3RyaW5nXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSB7QGxpbmsgRGVsaXZlcnlDbGllbnR9IHNob3VsZCBjYWxsIHRoZSBQcmV2aWV3IEFQSSBvciB0aGUgQ29udGVudCBEZWxpdmVyeSBlbmRwb2ludHMuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIElmIHRydWUgYW4gYXBpS2V5IG11c3QgYmUgc3VwcGxpZWQuXG4gICAqL1xuICBwcmV2aWV3PzogYm9vbGVhblxuICAvKipcbiAgICogVXNlZCB0byByZXRyaWV2ZSBhY2Nlc3MgdG9rZW5zIGZvciByZXF1ZXN0cyB0byB0aGUgQVBJcy5cbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgcmVxdWVzdCB0aGF0J3MgYWJvdXQgdG8gYmUgc2VudC5cbiAgICogQHJldHVybnMgYW4gb2F1dGggdG9rZW4gdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhpcyByZXF1ZXN0IG9yIHVuZGVmaW5lZCBpZiBubyB0b2tlbiBzaG91bGQgYmUgdXNlZC5cbiAgICovXG4gIGFjY2Vzc1Rva2VuUmVzb2x2ZXI/KHJlcXVlc3Q6IHsgZGF0YT86IGFueSwgaGVhZGVyczogYW55LCBtZXRob2Q6ICdnZXQnfCdHRVQnfCdwb3N0J3wnUE9TVCd8J3B1dCd8J1BVVCd8J2RlbGV0ZSd8J0RFTEVURScsIHVybDogc3RyaW5nIH0pOiBzdHJpbmcgfCB1bmRlZmluZWRcbn1cblxuLyoqXG4gKiBQcm94eSBvcHRpb25zXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJveHlPcHRpb25zIHtcbiAgLyoqXG4gICAqIEEgY3VzdG9tIHVybCBmb3IgdGhlIENvbnRlbnQgRGVsaXZlcnkgZW5kcG9pbnQuXG4gICAqL1xuICBjZG5Qcm94eVVybDogc3RyaW5nXG4gIC8qKlxuICAgKiBBIGN1c3RvbSB1cmwgZm9yIHRoZSBDb250ZW50IE1hbmFnZW1lbnQgZW5kcG9pbnQuXG4gICAqL1xuICBhcGlQcm94eVVybDogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBjdWx0dXJlIHNlbnQgd2l0aCBhbGwgcmVxdWVzdHMgdG8gdGhlIENvbnRlbnQgRGVsaXZlcnkgQVBJLCB0aGlzIGNhbiBiZSBvdmVyd3JpdHRlbiBwZXIgZnVuY3Rpb25cbiAgICovXG4gIGxhbmd1YWdlPzogc3RyaW5nXG59XG5cbi8qKlxuICogRW50cnkgY2xhc3MgZm9yIGFjY2Vzc2luZyB0aGUgQ29udGVudCBEZWxpdmVyeSBhbmQgQ29udGVudCBNYW5hZ2VtZW50IEFQSXMuXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBUbyBnZXQgc3RhcnRlZCB5b3UgbmVlZCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBDbGllbnRgIHBhc3Npbmcge0BsaW5rIENsaWVudE9wdGlvbnN9LlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IENsaWVudCB9IGZyb20gJ0B1bWJyYWNvL2hlYWRsZXNzLWNsaWVudCdcbiAqXG4gKiBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50KHtcbiAqICBwcm9qZWN0QWxpYXM6ICc8eW91ci1wcm9qZWN0LWFsaWFzPicsXG4gKiAgYXBpS2V5OiAnPHlvdXItYXBpLWtleT4nLFxuICogIGxhbmd1YWdlOiAnPGlzby1jb2RlPicsXG4gKiB9KVxuICogYGBgXG4gKlxuICogWW91IG1pZ2h0IHdhbnQgdG8gcHJveHkgeW91ciByZXF1ZXN0IHRocm91Z2ggYSBzZXJ2ZXIgdG8gaGlkZSB0aGUgcHJvamVjdCBhbGlhcyBhbmQgdGhlIGFwaSBrZXksXG4gKiB0aGlzIGNhbiBiZSBkb25lIGJ5IGNyZWF0aW5nIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgQ2xpZW50YCBjbGFzcyBwYXNzaW5nIGluIHtAbGluayBQcm94eU9wdGlvbnN9LlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IENsaWVudCB9IGZyb20gJ0B1bWJyYWNvL2hlYWRsZXNzLWNsaWVudCdcbiAqXG4gKiBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50KHtcbiAqICBhcGlQcm94eVVybDogJzxwcm94eS11cmw+JyxcbiAqICBjZG5Qcm94eVVybDogJzxwcm94eS11cmw+JyxcbiAqICBsYW5ndWFnZTogJzxpc28tY29kZT4nLFxuICogfSlcbiAqIGBgYFxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIENsaWVudCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgQ2xpZW50YCBjbGFzcyB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zLiBTZWUge0BsaW5rIENsaWVudE9wdGlvbnN9IG9yIHtAbGluayBQcm94eU9wdGlvbnN9LlxuICAgKi9cbiAgY29uc3RydWN0b3IgKHB1YmxpYyByZWFkb25seSBvcHRpb25zOiBDbGllbnRPcHRpb25zIHwgUHJveHlPcHRpb25zKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgRGVsaXZlcnkgY2xpZW50IGZvciBmZXRjaGluZyBjb250ZW50IGFuZCBtZWRpYSBmcm9tIENETi5cbiAgICogU2VlIHtAbGluayBEZWxpdmVyeUNsaWVudH1cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBkZWxpdmVyeSA9IG5ldyBEZWxpdmVyeUNsaWVudCh0aGlzKVxuXG4gIC8qKlxuICAgKiBHZXQgTWFuYWdlciBDbGllbnQgZm9yIG1hbmFnaW5nIGNvbnRlbnQgb24gVW1icmFjbyBIZWFydGNvcmUuXG4gICAqIFNlZSB7QGxpbmsgTWFuYWdlbWVudENsaWVudH1cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBtYW5hZ2VtZW50ID0gbmV3IE1hbmFnZW1lbnRDbGllbnQodGhpcylcblxuICAvKipcbiAgICogR2V0IEF1dGhlbnRpY2F0aW9uIENsaWVudCBmb3IgYXV0aGVudGljYXRpbmcgbWVtYmVycyBhbmQgQmFja29mZmljZSB1c2Vycy5cbiAgICogU2VlIHtAbGluayBBdXRoZW50aWNhdGlvbkNsaWVudH1cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBhdXRoZW50aWNhdGlvbiA9IG5ldyBBdXRoZW50aWNhdGlvbkNsaWVudCh0aGlzKVxuXG4gIC8qKlxuICAgKiBNYWtlcyByZXF1ZXN0IGZyb20gYW5kIFtFbmRwb2ludF1cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgbWFrZVJlcXVlc3QgPSBhc3luYyA8UiBleHRlbmRzIGFueT4oZW5kcG9pbnQ6IEVuZHBvaW50PFI+LCBkYXRhPzogYW55KTogUHJvbWlzZTxSPiA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBuZXcgQXBpUmVxdWVzdDxhbnk+KHRoaXMub3B0aW9ucywgZW5kcG9pbnQsIGRhdGEpLnByb21pc2UoKVxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5nZXRFbWJlZGRlZERhdGEocmVzcG9uc2UpXG4gICAgY29uc3QgcGFnZURhdGEgPSB0aGlzLmdldFBhZ2VkRGF0YShyZXNwb25zZSlcblxuICAgIGlmIChwYWdlRGF0YSAmJiBpdGVtcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucGFnZURhdGEsXG4gICAgICAgIGl0ZW1zXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghcGFnZURhdGEgJiYgaXRlbXMpIHtcbiAgICAgIGNvbnN0IHsgX2VtYmVkZGVkLCBfbGlua3MsIC4uLmRhdGEgfSA9IHJlc3BvbnNlXG4gICAgICBpZiAoT2JqZWN0LmtleXMoZGF0YSkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IC4uLl9lbWJlZGRlZCwgLi4uZGF0YSB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbXNcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgQVBJIHRvIGJlIHVzZWQuXG4gICAqIEBwYXJhbSBhcGlrZXkgLSBBUEkgS2V5XG4gICAqIEBkZXByZWNhdGVkIFVzZSBgYXBpS2V5YCBpbiB0aGUgY29uc3RydWN0b3Igb3B0aW9ucyBpbnN0ZWFkLlxuICAgKi9cbiAgcHVibGljIHNldEFQSUtleSA9IChhcGlrZXk6IHN0cmluZykgPT4ge1xuICAgIGlmKCdhcGlLZXknIGluIHRoaXMub3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zLmFwaUtleSA9IGFwaWtleVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2Fubm90IHNldCBhcGlLZXkgb24gUHJveHlPcHRpb25zJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBvcHRpb25zLmFwaUtleWAgaW5zdGVhZC5cbiAgICovXG4gIHB1YmxpYyBnZXRBUElLZXkgPSAoKSA9PiB7XG4gICAgaWYoJ2FwaUtleScgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmFwaUtleVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2Fubm90IHNldCBhcGlLZXkgb24gUHJveHlPcHRpb25zJylcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlYWRvbmx5IGdldEVtYmVkZGVkRGF0YSA9IChyZXNwb25zZTogYW55KSA9PiB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXNwb25zZSwgJ19lbWJlZGRlZCcpKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmVzcG9uc2UuX2VtYmVkZGVkKVxuICAgICAgY29uc3Qga2V5Q291bnQgPSBrZXlzLmxlbmd0aFxuICAgICAgaWYgKGtleUNvdW50ID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbMF1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLl9lbWJlZGRlZFtrZXldXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHByaXZhdGUgcmVhZG9ubHkgZ2V0UGFnZWREYXRhID0gKHJlc3BvbnNlOiBhbnkpID0+IHtcbiAgICBjb25zdCBsb29rRm9yUHJvcHMgPSBbJ190b3RhbEl0ZW1zJywgJ190b3RhbFBhZ2VzJywgJ19wYWdlJywgJ19wYWdlU2l6ZSddXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlc3BvbnNlKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb29rRm9yUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5lZWRsZSA9IGxvb2tGb3JQcm9wc1tpXVxuICAgICAgaWYgKCFrZXlzLmluY2x1ZGVzKG5lZWRsZSkpIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgY29uc3Qgb2JqZWN0OiBhbnkgPSB7fVxuICAgIGxvb2tGb3JQcm9wcy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBvYmplY3Rba2V5LnJlcGxhY2UoL15fLywgJycpXSA9IHJlc3BvbnNlW2tleV1cbiAgICB9KVxuXG4gICAgcmV0dXJuIG9iamVjdFxuICB9XG59XG4iXX0=